<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepGraph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* CSS Custom Properties - Design System */
        :root {
            /* Colors - Light Theme */
            --background: 0 0% 100%;
            --foreground: 240 10% 3.9%;
            --card: 0 0% 100%;
            --card-foreground: 240 10% 3.9%;
            --popover: 0 0% 100%;
            --popover-foreground: 240 10% 3.9%;
            --primary: 240 9% 9%;
            --primary-foreground: 0 0% 98%;
            --secondary: 240 4.8% 95.9%;
            --secondary-foreground: 240 5.9% 10%;
            --muted: 240 4.8% 95.9%;
            --muted-foreground: 240 3.8% 46.1%;
            --accent: 240 4.8% 95.9%;
            --accent-foreground: 240 5.9% 10%;
            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 0 0% 98%;
            --border: 240 5.9% 90%;
            --input: 240 5.9% 90%;
            --ring: 240 5.9% 10%;
            --radius: 0.5rem;
            
            /* Spacing Scale */
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-5: 1.25rem;
            --space-6: 1.5rem;
            --space-8: 2rem;
            --space-10: 2.5rem;
            --space-12: 3rem;
            --space-16: 4rem;
            --space-20: 5rem;
            
            /* Typography */
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            --font-size-2xl: 1.5rem;
            --font-size-3xl: 1.875rem;
            --font-size-4xl: 2.25rem;
            --font-size-5xl: 3rem;
        }
        
        /* Dark Theme */
        .dark {
            --background: 240 10% 3.9%;
            --foreground: 0 0% 98%;
            --card: 240 10% 3.9%;
            --card-foreground: 0 0% 98%;
            --popover: 240 10% 3.9%;
            --popover-foreground: 0 0% 98%;
            --primary: 0 0% 98%;
            --primary-foreground: 240 5.9% 10%;
            --secondary: 240 3.7% 15.9%;
            --secondary-foreground: 0 0% 98%;
            --muted: 240 3.7% 15.9%;
            --muted-foreground: 240 5% 64.9%;
            --accent: 240 3.7% 15.9%;
            --accent-foreground: 0 0% 98%;
            --destructive: 0 62.8% 30.6%;
            --destructive-foreground: 0 0% 98%;
            --border: 240 3.7% 15.9%;
            --input: 240 3.7% 15.9%;
            --ring: 240 4.9% 83.9%;
        }
        
        /* Global Styles */
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: "Inter", sans-serif;
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            min-height: 100vh;
            padding: 0;
            margin: 0;
            overflow: hidden;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Full-screen Graph Container */
        #graphContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: hsl(var(--background));
            z-index: 1;
            overflow: hidden;
        }

        /* D3.js Graph Elements */
        .link {
            stroke: hsl(var(--muted-foreground) / 0.4);
            stroke-width: 1.5px;
            transition: stroke 0.2s ease-in-out;
        }
        .link:hover {
            stroke: hsl(var(--foreground) / 0.6);
        }

        .node circle {
            stroke: hsl(var(--border));
            stroke-width: 2px;
            fill: hsl(var(--card));
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            filter: drop-shadow(0 1px 2px hsl(var(--muted-foreground) / 0.1));
        }
        .node circle:hover {
            stroke: hsl(var(--primary));
            fill: hsl(var(--accent));
            transform: scale(1.05);
            filter: drop-shadow(0 4px 8px hsl(var(--muted-foreground) / 0.15));
        }
        .node text {
            font-size: var(--font-size-sm);
            text-anchor: middle;
            fill: hsl(var(--foreground));
            pointer-events: none;
            user-select: none;
            font-weight: 500;
        }
        .link-label {
            font-size: var(--font-size-xs);
            fill: hsl(var(--muted-foreground));
            text-anchor: middle;
            user-select: none;
            font-weight: 400;
            transition: fill 0.2s ease-in-out;
        }
        .link-label:hover {
            fill: hsl(var(--foreground));
        }
        marker#arrow {
            fill: hsl(var(--muted-foreground) / 0.4);
        }
        
        /* Utility Classes */
        .hidden {
            display: none !important;
        }
        
        /* Chatbot Styles */
        #chatBotContainer {
            position: fixed;
            bottom: var(--space-6);
            right: var(--space-6);
            width: 24rem;
            height: 32rem;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: calc(var(--radius) + 4px);
            box-shadow: 0 10px 15px -3px hsl(var(--foreground) / 0.1);
            z-index: 20;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        #chatHeader {
            background: hsl(var(--muted));
            color: hsl(var(--foreground));
            padding: var(--space-4);
            font-weight: 600;
            font-size: var(--font-size-base);
            border-bottom: 1px solid hsl(var(--border));
            text-align: center;
            cursor: grab;
        }
        
        #chatHistory {
            flex-grow: 1;
            padding: var(--space-4);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }
        
        .chat-message {
            background: hsl(var(--muted) / 0.5);
            padding: var(--space-3);
            border-radius: var(--radius);
            color: hsl(var(--foreground));
            font-size: var(--font-size-sm);
            line-height: 1.4;
            word-wrap: break-word;
        }
        
        .chat-message.user {
            align-self: flex-end;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border-bottom-right-radius: 4px;
        }
        
        .chat-message.ai {
            align-self: flex-start;
            background: hsl(var(--muted));
            border-bottom-left-radius: 4px;
        }
        
        #chatInputContainer {
            display: flex;
            padding: var(--space-4);
            border-top: 1px solid hsl(var(--border));
            gap: var(--space-2);
        }
        
        #chatInput {
            flex-grow: 1;
            background: hsl(var(--background));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: var(--space-2) var(--space-3);
            color: hsl(var(--foreground));
            font-size: var(--font-size-sm);
        }
        
        #chatInput:focus {
            outline: none;
            border-color: hsl(var(--ring));
            box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
        }
        
        #sendChatBtn {
            padding: var(--space-2) var(--space-4);
            font-size: var(--font-size-sm);
        }
        
        /* Node Info Popup */
        #nodeInfoPopup {
            position: absolute;
            background: hsl(var(--popover));
            color: hsl(var(--popover-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: calc(var(--radius) + 2px);
            padding: var(--space-6);
            width: 20rem;
            max-height: 24rem;
            overflow-y: auto;
            z-index: 50;
            display: none;
            flex-direction: column;
            gap: var(--space-3);
            box-shadow: 0 10px 15px -3px hsl(var(--foreground) / 0.1);
        }
        
        #nodeInfoPopup h3 {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: hsl(var(--foreground));
            margin: 0 0 var(--space-2) 0;
            text-align: center;
        }
        
        #nodeInfoPopup p {
            font-size: var(--font-size-sm);
            line-height: 1.5;
            color: hsl(var(--muted-foreground));
            margin: 0;
        }
        
        #nodeInfoPopup .close-btn {
            position: absolute;
            top: var(--space-2);
            right: var(--space-2);
            background: none;
            border: none;
            color: hsl(var(--muted-foreground));
            font-size: var(--font-size-lg);
            cursor: pointer;
            padding: var(--space-2);
            border-radius: var(--radius);
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        #nodeInfoPopup .close-btn:hover {
            background: hsl(var(--muted));
            color: hsl(var(--foreground));
        }

        #graphPlaceholder {
            color: hsl(var(--muted-foreground));
            font-size: var(--font-size-xl);
            font-weight: 600;
            letter-spacing: -0.01em;
        }

        /* Card Component */
        .card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: hsl(var(--card));
            color: hsl(var(--card-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: calc(var(--radius) + 2px);
            padding: var(--space-8);
            width: 90%;
            max-width: 32rem;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: var(--space-6);
            box-shadow: 0 10px 15px -3px hsl(var(--foreground) / 0.1), 0 4px 6px -2px hsl(var(--foreground) / 0.05);
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        }
        .card.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -48%);
        }

        /* Card Header */
        .card-header {
            text-align: center;
            margin-bottom: var(--space-6);
        }
        .card-header h1 {
            font-size: var(--font-size-3xl);
            font-weight: 700;
            color: hsl(var(--foreground));
            letter-spacing: -0.025em;
            line-height: 1.2;
            margin: 0 0 var(--space-3) 0;
        }
        .card-header p {
            font-size: var(--font-size-base);
            color: hsl(var(--muted-foreground));
            margin: 0;
            line-height: 1.5;
        }

        /* Form Elements */
        .form-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }
        
        .form-label {
            font-size: var(--font-size-sm);
            font-weight: 500;
            color: hsl(var(--foreground));
        }
        
        .input, .textarea {
            width: 100%;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: var(--space-2) var(--space-3);
            font-size: var(--font-size-sm);
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        
        .input {
            min-height: 2.5rem;
        }
        
        .textarea {
            min-height: 8rem;
            resize: vertical;
            line-height: 1.5;
        }
        
        .input::placeholder, .textarea::placeholder {
            color: hsl(var(--muted-foreground));
        }
        
        .input:focus, .textarea:focus {
            outline: none;
            border-color: hsl(var(--ring));
            box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
        }

        /* File Upload Area */
        .file-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-4);
            padding: var(--space-8);
            border: 2px dashed hsl(var(--border));
            border-radius: calc(var(--radius) + 2px);
            background: hsl(var(--muted) / 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .file-upload-area:hover {
            background: hsl(var(--muted));
            border-color: hsl(var(--primary));
        }
        .file-upload-area input[type="file"] {
            display: none;
        }
        .file-upload-area label {
            font-size: var(--font-size-base);
            color: hsl(var(--foreground));
            font-weight: 500;
            cursor: pointer;
        }
        .file-upload-area .file-icon {
            font-size: var(--font-size-5xl);
            color: hsl(var(--muted-foreground));
        }
        .file-upload-area #fileNameDisplay {
            color: hsl(var(--muted-foreground));
            font-size: var(--font-size-sm);
        }

        /* Divider */
        .divider {
            display: flex;
            align-items: center;
            text-align: center;
            color: hsl(var(--muted-foreground));
            font-size: var(--font-size-sm);
            margin: var(--space-6) 0;
        }
        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid hsl(var(--border));
        }
        .divider:not(:empty)::before {
            margin-right: var(--space-4);
        }
        .divider:not(:empty)::after {
            margin-left: var(--space-4);
        }

        /* Button Components */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            border-radius: var(--radius);
            font-size: var(--font-size-sm);
            font-weight: 500;
            transition: all 0.2s ease;
            cursor: pointer;
            border: 1px solid transparent;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .btn-primary {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            padding: var(--space-2) var(--space-4);
        }
        .btn-primary:hover {
            background: hsl(var(--primary) / 0.9);
        }
        
        .btn-lg {
            padding: var(--space-3) var(--space-8);
            font-size: var(--font-size-base);
        }
        /* Button Positions */
        .btn-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .btn-top-left {
            position: fixed;
            top: var(--space-5);
            left: var(--space-5);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Loading Spinner */
        .spinner {
            border: 2px solid hsl(var(--border));
            border-top: 2px solid hsl(var(--primary));
            border-radius: 50%;
            width: 1rem;
            height: 1rem;
            animation: spin 1s linear infinite;
        }
        
        .spinner-lg {
            width: 1.5rem;
            height: 1.5rem;
            border-width: 3px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Dialog/Alert Box */
        .alert-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: hsl(var(--card));
            color: hsl(var(--card-foreground));
            padding: var(--space-6);
            border-radius: calc(var(--radius) + 4px);
            box-shadow: 0 25px 50px -12px hsl(var(--foreground) / 0.25);
            z-index: 50;
            display: none;
            flex-direction: column;
            gap: var(--space-4);
            align-items: center;
            text-align: center;
            max-width: 28rem;
            width: 90%;
            border: 1px solid hsl(var(--border));
        }
        .alert-dialog p {
            font-size: var(--font-size-base);
            color: hsl(var(--foreground));
            line-height: 1.5;
            margin: 0;
        }
        .alert-dialog .btn {
            margin-top: var(--space-2);
        }

        /* Progress Overlay */
        #progressBarOverlay {
            position: fixed;
            inset: 0;
            background: hsl(var(--background) / 0.8);
            backdrop-filter: blur(8px);
            z-index: 50;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: var(--space-8);
            color: hsl(var(--foreground));
            font-size: var(--font-size-xl);
            font-weight: 600;
        }
        #progressBarContainer {
            width: 80%;
            max-width: 24rem;
            background: hsl(var(--secondary));
            border-radius: var(--radius);
            height: 0.5rem;
            overflow: hidden;
        }
        #progressBarFill {
            height: 100%;
            width: 0%;
            background: hsl(var(--primary));
            transition: width 0.3s ease;
        }
        #progressText {
            font-size: var(--font-size-base);
            color: hsl(var(--muted-foreground));
        }

        /* Chatbot Styles */
        #chatBotContainer {
            position: fixed;
            bottom: 25px; /* Slightly more off bottom */
            right: 25px; /* Slightly more off right */
            width: 380px; /* Slightly wider */
            height: 650px; /* Slightly taller */
            background-color: rgba(0, 0, 0, 0.8); /* Darker background */
            backdrop-filter: blur(12px); /* Increased blur */
            border: 1px solid rgba(255, 255, 255, 0.15); /* More prominent border */
            border-radius: 20px; /* More rounded */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); /* Stronger shadow */
            z-index: 20;
            display: none;
            flex-direction: column;
            overflow: hidden;
            cursor: grab;
        }
        #chatHeader {
            background-color: rgba(255, 255, 255, 0.15); /* More prominent header background */
            color: #ffffff;
            padding: 18px; /* More padding */
            font-weight: 700;
            font-size: 1.2rem; /* Larger font */
            border-bottom: 1px solid rgba(255, 255, 255, 0.25); /* More prominent border */
            text-align: center;
            cursor: grab;
        }
        #chatHistory {
            flex-grow: 1;
            padding: 20px; /* More padding */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px; /* More space between messages */
            scrollbar-width: thin;
            scrollbar-color: #a0a0a0 #0a0a0a; /* Lighter thumb, darker track */
        }
        #chatHistory::-webkit-scrollbar {
            width: 10px; /* Wider scrollbar */
        }
        #chatHistory::-webkit-scrollbar-track {
            background: #0a0a0a; /* Darker track */
            border-radius: 10px;
        }
        #chatHistory::-webkit-scrollbar-thumb {
            background-color: #a0a0a0; /* Lighter thumb */
            border-radius: 10px;
            border: 2px solid #0a0a0a; /* Darker border for thumb */
        }
        .chat-message {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 12px 18px; /* More padding */
            border-radius: 12px; /* More rounded */
            color: #e0e0e0; /* Lighter text */
            font-size: 0.95rem; /* Slightly larger font */
            line-height: 1.5;
            word-wrap: break-word;
        }
        .chat-message.user {
            align-self: flex-end;
            background-color: rgba(255, 255, 255, 0.2); /* More distinct user message */
            border-bottom-right-radius: 4px; /* Slightly larger corner adjustment */
        }
        .chat-message.ai {
            align-self: flex-start;
            background-color: rgba(255, 255, 255, 0.15); /* More distinct AI message */
            border-bottom-left-radius: 4px; /* Slightly larger corner adjustment */
        }
        #chatInputContainer {
            display: flex;
            padding: 18px; /* More padding */
            border-top: 1px solid rgba(255, 255, 255, 0.25); /* More prominent border */
            gap: 12px; /* More space */
        }
        #chatInput {
            flex-grow: 1;
            background-color: rgba(0, 0, 0, 0.6); /* Darker input background */
            border: 1px solid rgba(255, 255, 255, 0.35); /* More prominent border */
            border-radius: 10px; /* More rounded */
            padding: 12px 18px; /* More padding */
            color: #ffffff;
            font-size: 1rem; /* Slightly larger font */
        }
        #chatInput:focus {
            outline: none;
            border-color: #ffffff;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2); /* Subtle glow on focus */
        }
        #sendChatBtn {
            background-image: linear-gradient(to right, #404041, #1e1e20);
            color: white;
            padding: 12px 20px; /* More padding */
            border-radius: 10px; /* More rounded */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* Subtle shadow */
            font-size: 1rem; /* Slightly larger font */
            text-transform: none;
            letter-spacing: normal;
            position: static;
            transform: none;
        }
        #sendChatBtn:hover {
            background-image: linear-gradient(to right, #1e1e20, #0d0d0e);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        #sendChatBtn:disabled {
            background-image: linear-gradient(to right, #505052, #303032);
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        .chat-loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #ffffff;
            border-radius: 50%;
            width: 18px; /* Slightly larger */
            height: 18px;
            animation: spin 1s linear infinite;
        }

        /* Node Info Pop-up Styles */
        #nodeInfoPopup {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8); /* Darker background */
            backdrop-filter: blur(10px); /* Increased blur */
            border: 1px solid rgba(255, 255, 255, 0.2); /* More prominent border */
            border-radius: 18px; /* More rounded */
            padding: 25px; /* More padding */
            width: 320px; /* Slightly wider */
            max-height: 450px; /* Taller */
            overflow-y: auto;
            color: #ffffff;
            z-index: 50;
            display: none;
            flex-direction: column;
            gap: 12px; /* More space */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6); /* Stronger shadow */
            transform: translate(-50%, -50%);
            pointer-events: auto;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #nodeInfoPopup h3 {
            font-size: 1.5rem; /* Larger title */
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 8px;
            text-align: center;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        #nodeInfoPopup p {
            font-size: 0.95rem; /* Slightly larger text */
            line-height: 1.6;
            color: #d0d0d0; /* Lighter gray */
        }
        #nodeInfoPopup .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #ffffff;
            font-size: 1.8rem; /* Larger close button */
            cursor: pointer;
            padding: 8px; /* More padding */
            border-radius: 50%;
            transition: background-color 0.2s, transform 0.2s;
            z-index: 101 !important; /* Ensure this is on top */
        }
        #nodeInfoPopup .close-btn:hover {
            background-color: rgba(255, 255, 255, 0.15);
            transform: rotate(90deg); /* Rotate on hover */
        }
        #nodeInfoPopup .popup-loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 22px; /* Slightly larger */
            height: 22px;
            animation: spin 1s linear infinite;
            margin: 15px auto; /* More margin */
        }

        /* Welcome Portal */
        #welcomePortal {
            position: fixed;
            inset: 0;
            background: hsl(var(--background));
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: hsl(var(--foreground));
            text-align: center;
            gap: var(--space-12);
            transition: opacity 0.3s ease;
        }
        #welcomePortal.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #welcomePortal h1 {
            font-size: var(--font-size-5xl);
            font-weight: 800;
            letter-spacing: -0.025em;
            line-height: 1;
        }
        #welcomePortal p {
            font-size: var(--font-size-xl);
            max-width: 42rem;
            line-height: 1.6;
            color: hsl(var(--muted-foreground));
            padding: 0 var(--space-5);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .card {
                padding: var(--space-6);
                max-width: 95%;
            }
            .card-header h1 {
                font-size: var(--font-size-2xl);
            }
            .input, .textarea {
                font-size: var(--font-size-base);
            }
            .textarea {
                min-height: 6rem;
            }
            .btn-lg {
                padding: var(--space-2) var(--space-6);
            }
            .file-upload-area {
                padding: var(--space-6);
            }
            .file-upload-area .file-icon {
                font-size: var(--font-size-4xl);
            }
            #welcomePortal h1 {
                font-size: var(--font-size-4xl);
            }
            #welcomePortal p {
                font-size: var(--font-size-lg);
            }
            #chatBotContainer {
                width: 90vw;
                height: 70vh;
                bottom: var(--space-4);
                right: var(--space-4);
                left: 5vw;
            }
            #nodeInfoPopup {
                width: 90vw;
                max-height: 60vh;
                padding: var(--space-5);
            }
        }
    </style>
</head>
<body class="dark">
    <div id="welcomePortal">
        <h1>Welcome to DeepGraph</h1>
        <p>Transform complex research reports into interactive knowledge graphs and chat with AI to explore insights.</p>
        <button id="getStartedBtn" class="btn btn-primary btn-lg">Get Started</button>
    </div>

    <div id="graphContainer">
        <svg id="knowledgeGraphSvg" class="w-full h-full absolute top-0 left-0"></svg>
        <div id="graphPlaceholder" class="absolute inset-0 flex items-center justify-center text-2xl font-semibold p-4">
            Your interactive knowledge graph will be visualized here.
        </div>
    </div>

    <button id="openInputModalBtn" class="btn btn-primary btn-center hidden">
        <span id="openButtonText">Generate Knowledge Graph</span>
        <i class="fas fa-project-diagram"></i>
    </button>

    <div id="inputModal" class="card hidden">
        <div class="card-header">
            <h1 id="modalTitle">Generate Knowledge Graph</h1>
            <p id="modalSubtitle">Enter your report details below.</p>
        </div>

        <div id="reportInputSection">
            <div class="form-group">
                <label for="apiKeyInput" class="form-label">Gemini API Key:</label>
                <input type="text" id="apiKeyInput" class="input" placeholder="Enter your Gemini API Key here">
            </div>

            <div class="file-upload-area" id="fileUploadArea">
                <span class="file-icon"><i class="fas fa-file-pdf"></i></span>
                <label for="pdfUploadInput">Click to Upload PDF</label>
                <input type="file" id="pdfUploadInput" accept=".pdf">
                <span id="fileNameDisplay">No file chosen</span>
                <div id="pdfLoadingSpinner" class="spinner hidden"></div>
            </div>

            <div class="divider"><span>OR</span></div>

            <div class="form-group">
                <label for="reportInput" class="form-label">Paste your research report here:</label>
                <textarea id="reportInput" class="textarea" placeholder="E.g., 'The study investigated the effects of climate change on polar bear populations. Rising temperatures lead to melting ice caps, reducing hunting grounds for seals, their primary food source. This results in decreased polar bear health and reproductive rates.'"></textarea>
            </div>

            <button id="submitInputBtn" class="btn btn-primary btn-lg">
                <span id="submitButtonText">Generate Graph</span>
                <div id="submitLoadingSpinner" class="spinner hidden"></div>
            </button>
        </div>
    </div>

    <div id="progressBarOverlay">
        <p>Generating Knowledge Graph...</p>
        <div id="progressBarContainer">
            <div id="progressBarFill"></div>
        </div>
        <span id="progressText">0%</span>
    </div>

    <div id="chatBotContainer">
        <div id="chatHeader">Chat with Graph AI <i class="fas fa-robot ml-2"></i></div>
        <div id="chatHistory">
            <div class="chat-message ai">Hello! Ask me anything about the knowledge graph.</div>
        </div>
        <div id="chatInputContainer">
            <input type="text" id="chatInput" placeholder="Ask about the graph...">
            <button id="sendChatBtn">
                <span id="sendButtonText">Send</span>
                <div id="chatLoadingSpinner" class="chat-loading-spinner hidden"></div>
            </button>
        </div>
    </div>

    <div id="nodeInfoPopup" class="hidden">
        <button class="close-btn" id="closeNodeInfoPopup"><i class="fas fa-times"></i></button>
        <h3 id="popupNodeTitle"></h3>
        <div id="popupNodeSummary">
            <div class="popup-loading-spinner"></div>
        </div>
    </div>

    <div id="messageBox" class="alert-dialog">
        <p id="messageBoxText"></p>
        <button id="messageBoxOkBtn" class="btn btn-primary">OK</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // Set PDF.js worker source
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Global variables for Firebase (Canvas environment auth)
        let app;
        let auth;

        // Global variables to store the current graph data for chatbot
        let currentGraphNodes = [];
        let currentGraphLinks = [];

        // UI elements
        const welcomePortal = document.getElementById('welcomePortal');
        const getStartedBtn = document.getElementById('getStartedBtn');

        const openInputModalBtn = document.getElementById('openInputModalBtn');
        const inputModal = document.getElementById('inputModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalSubtitle = document.getElementById('modalSubtitle');

        const reportInputSection = document.getElementById('reportInputSection'); // Now always visible

        const reportInput = document.getElementById('reportInput');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const submitInputBtn = document.getElementById('submitInputBtn');
        const submitButtonText = document.getElementById('submitButtonText');
        const submitLoadingSpinner = document.getElementById('submitLoadingSpinner');
        const graphContainer = document.getElementById('graphContainer');
        const knowledgeGraphSvg = document.getElementById('knowledgeGraphSvg');
        const graphPlaceholder = document.getElementById('graphPlaceholder');
        const pdfUploadInput = document.getElementById('pdfUploadInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const pdfLoadingSpinner = document.getElementById('pdfLoadingSpinner');
        const fileUploadArea = document.getElementById('fileUploadArea');
        const progressBarOverlay = document.getElementById('progressBarOverlay');
        const progressBarFill = document.getElementById('progressBarFill');
        const progressText = document.getElementById('progressText');

        // Chatbot elements
        const chatBotContainer = document.getElementById('chatBotContainer');
        const chatHeader = document.getElementById('chatHeader');
        const chatHistory = document.getElementById('chatHistory');
        const chatInput = document.getElementById('chatInput');
        const sendChatBtn = document.getElementById('sendChatBtn');
        const sendButtonText = document.getElementById('sendButtonText');
        const chatLoadingSpinner = document.getElementById('chatLoadingSpinner');

        // Node Info Pop-up elements
        const nodeInfoPopup = document.getElementById('nodeInfoPopup');
        const closeNodeInfoPopupBtn = document.getElementById('closeNodeInfoPopup');
        const popupNodeTitle = document.getElementById('popupNodeTitle');
        const popupNodeSummary = document.getElementById('popupNodeSummary');

        let progressInterval;
        let isDraggingChatbot = false;
        let chatbotOffsetX, chatbotOffsetY;

        let width = window.innerWidth;
        let height = window.innerHeight;

        // --- Firebase Initialization (for Canvas environment) ---
        async function initializeFirebase() {
            try {
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing or empty.");
                    showMessageBox("Firebase configuration is missing. Please ensure the environment is set up correctly.");
                    return;
                }
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);

                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                console.log("Firebase initialized and authenticated for Canvas environment.");
            } catch (error) {
                console.error("Error initializing Firebase or authenticating:", error);
                showMessageBox("Failed to initialize Firebase or authenticate for Canvas. Please try again later.");
            }
        }
        initializeFirebase();

        function updateAuthUI(user) {
            // This function is simplified as auth is removed.
            // It now just ensures the report input section is visible.
            reportInputSection.classList.remove('hidden');
            modalTitle.textContent = "Generate Knowledge Graph";
            modalSubtitle.textContent = "Enter your report details below.";
        }

        // --- UI Event Listeners ---
        document.getElementById('messageBoxOkBtn').addEventListener('click', () => {
            document.getElementById('messageBox').style.display = 'none';
        });

        // Function to handle opening the input modal (simplified)
        async function handleOpenInputModal() {
            inputModal.classList.remove('hidden');
            updateAuthUI(null); // Call to ensure report input section is visible
        }

        // Open input/auth modal
        openInputModalBtn.addEventListener('click', handleOpenInputModal);

        // --- Existing App Logic ---
        const svg = d3.select("#knowledgeGraphSvg")
            .attr("viewBox", [0, 0, width, height]);

        svg.append("defs").append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("class", "arrowhead");

        const g = svg.append("g");

        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(200))
            .force("charge", d3.forceManyBody().strength(-500))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(30));

        let link, node, linkLabel;

        const zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
        svg.call(zoom);

        function resizeGraph() {
            width = window.innerWidth;
            height = window.innerHeight;
            svg.attr("viewBox", [0, 0, width, height]);
            simulation.force("center", d3.forceCenter(width / 2, height / 2));
            simulation.alpha(0.3).restart();
        }

        function renderGraph(nodes, links) {
            currentGraphNodes = nodes;
            currentGraphLinks = links;

            graphPlaceholder.classList.add('hidden');
            g.selectAll("*").remove();

            link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("class", "link")
                .attr("marker-end", "url(#arrow)");

            linkLabel = g.append("g")
                .attr("class", "link-labels")
                .selectAll("text")
                .data(links)
                .enter().append("text")
                .attr("class", "link-label")
                .text(d => d.type);

            node = g.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            node.append("circle")
                .attr("r", 18)
                .attr("fill", "rgba(255, 255, 255, 0.15)");

            node.append("text")
                .attr("dy", "0.35em")
                .attr("y", -25)
                .text(d => d.label);

            node.on("click", async (event, d) => {
                event.stopPropagation();
                await showNodeInfoPopup(d.label, d.x, d.y);
            });

            simulation
                .nodes(nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(links);

            simulation.alpha(1).restart();

            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                linkLabel
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2 - 10);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            }

            setMainButtonPosition('top-left');
            chatBotContainer.style.display = 'flex';
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function showMessageBox(message) {
            const messageBox = document.getElementById('messageBox');
            const messageBoxText = document.getElementById('messageBoxText');
            messageBoxText.textContent = message;
            messageBox.style.display = 'flex';
        }

        function setMainButtonPosition(position) {
            if (position === 'center') {
                openInputModalBtn.classList.remove('btn-top-left');
                openInputModalBtn.classList.add('btn-center');
            } else if (position === 'top-left') {
                openInputModalBtn.classList.remove('btn-center');
                openInputModalBtn.classList.add('btn-top-left');
            }
        }

        function setLoadingState(isLoading) {
            submitInputBtn.disabled = isLoading;
            if (isLoading) {
                submitButtonText.style.display = 'none';
                submitLoadingSpinner.classList.remove('hidden');
            } else {
                submitButtonText.style.display = 'inline';
                submitLoadingSpinner.classList.add('hidden');
            }
        }

        function setPdfLoadingState(isLoading) {
            pdfUploadInput.disabled = isLoading;
            fileUploadArea.style.cursor = isLoading ? 'not-allowed' : 'pointer';
            if (isLoading) {
                pdfLoadingSpinner.classList.remove('hidden');
                fileNameDisplay.textContent = 'Processing PDF...';
            } else {
                pdfLoadingSpinner.classList.add('hidden');
            }
        }

        function showProgressBar() {
            progressBarOverlay.style.display = 'flex';
            progressBarFill.style.width = '0%';
            progressText.textContent = '0%';
            let progress = 0;
            progressInterval = setInterval(() => {
                if (progress < 95) {
                    progress += Math.random() * 5;
                    if (progress > 95) progress = 95;
                    progressBarFill.style.width = `${progress}%`;
                    progressText.textContent = `${Math.floor(progress)}%`;
                }
            }, 200);
        }

        function hideProgressBar() {
            clearInterval(progressInterval);
            progressBarFill.style.width = '100%';
            progressText.textContent = '100%';
            setTimeout(() => {
                progressBarOverlay.style.display = 'none';
            }, 500);
        }

        pdfUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                fileNameDisplay.textContent = 'No file chosen';
                return;
            }

            if (file.type !== 'application/pdf') {
                showMessageBox("Please upload a valid PDF file.");
                fileNameDisplay.textContent = 'No file chosen';
                pdfUploadInput.value = '';
                return;
            }

            fileNameDisplay.textContent = file.name;
            setPdfLoadingState(true);
            reportInput.value = '';

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const pdfData = new Uint8Array(e.target.result);
                    const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                    const pdf = await loadingTask.promise;
                    let fullText = '';

                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + '\n';
                    }
                    reportInput.value = fullText.trim();
                    showMessageBox("PDF content loaded successfully into the text area. Click 'Generate Graph' to visualize.");
                } catch (error) {
                    console.error("Error processing PDF:", error);
                    showMessageBox("Failed to process PDF. It might be corrupted or in an unsupported format.");
                    reportInput.value = '';
                } finally {
                    setPdfLoadingState(false);
                }
            };
            reader.readAsArrayBuffer(file);
        });

        fileUploadArea.addEventListener('click', () => {
            if (!pdfUploadInput.disabled) {
                pdfUploadInput.click();
            }
        });

        submitInputBtn.addEventListener('click', async () => {
            const reportText = reportInput.value.trim();
            const userApiKey = apiKeyInput.value.trim();

            if (!userApiKey) {
                showMessageBox("Please enter your Gemini API Key.");
                return;
            }

            if (!reportText) {
                showMessageBox("Please enter a research report or upload a PDF to generate the knowledge graph.");
                return;
            }

            setLoadingState(true);
            inputModal.classList.add('hidden');
            showProgressBar();

            try {
                let chatHistory = [];
                const prompt = `Analyze the following research report and extract key concepts (nodes) and their relationships (links). Represent the output as a JSON object with two arrays: 'nodes' and 'links'.
Each node should have an 'id' (unique identifier, e.g., a simplified concept name) and a 'label' (the full concept name).
Each link should have a 'source' (id of the source node), a 'target' (id of the target node), and a 'type' (description of the relationship, e.g., 'explains', 'is_a', 'causes', 'has_property', 'impacts', 'leads_to', 'associated_with', 'part_of').
Ensure the relationships are meaningful and reflect the core ideas and connections within the text. Focus on scientific or technical concepts and their interdependencies.

Research Report:
${reportText}`;

                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "nodes": {
                                    "type": "ARRAY",
                                    "items": {
                                        "type": "OBJECT",
                                        "properties": {
                                            "id": { "type": "STRING" },
                                            "label": { "type": "STRING" }
                                        },
                                        "propertyOrdering": ["id", "label"]
                                    }
                                },
                                "links": {
                                    "type": "ARRAY",
                                    "items": {
                                        "type": "OBJECT",
                                        "properties": {
                                            "source": { "type": "STRING" },
                                            "target": { "type": "STRING" },
                                            "type": { "type": "STRING" }
                                        },
                                        "propertyOrdering": ["source", "target", "type"]
                                    }
                                }
                            },
                            "propertyOrdering": ["nodes", "links"]
                        }
                    }
                };

                const apiKey = userApiKey;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Response for Graph Generation:", result);

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;
                    const graphData = JSON.parse(jsonString);

                    if (graphData.nodes && graphData.links) {
                        renderGraph(graphData.nodes, graphData.links);
                    } else {
                        showMessageBox("The AI could not generate a valid knowledge graph from the provided text. This might happen with very short or unstructured text.");
                        graphPlaceholder.classList.remove('hidden');
                    }
                } else {
                    showMessageBox("Failed to get a response from the AI. Please check your API key or try again.");
                    graphPlaceholder.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Error generating knowledge graph:", error);
                showMessageBox("An error occurred while generating the knowledge graph. Please check your input and API key, then try again.");
                graphPlaceholder.classList.remove('hidden');
            } finally {
                setLoadingState(false);
                hideProgressBar();
            }
        });

        sendChatBtn.addEventListener('click', async () => {
            const userQuestion = chatInput.value.trim();
            if (!userQuestion) {
                showMessageBox("Please type a question for the chatbot.");
                return;
            }

            if (currentGraphNodes.length === 0) {
                showMessageBox("Please generate a knowledge graph first before asking questions.");
                chatInput.value = '';
                return;
            }

            const userMessageDiv = document.createElement('div');
            userMessageDiv.classList.add('chat-message', 'user');
            userMessageDiv.textContent = userQuestion;
            chatHistory.appendChild(userMessageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            chatInput.value = '';
            sendChatBtn.disabled = true;
            sendButtonText.style.display = 'none';
            chatLoadingSpinner.classList.remove('hidden');

            try {
                const userApiKey = apiKeyInput.value.trim();
                if (!userApiKey) {
                    showMessageBox("Please enter your Gemini API Key in the input modal to use the chatbot.");
                    sendChatBtn.disabled = false;
                    sendButtonText.classList.remove('hidden');
                    chatLoadingSpinner.classList.add('hidden');
                    return;
                }

                const graphJson = JSON.stringify({ nodes: currentGraphNodes, links: currentGraphLinks });

                let chatHistoryForAI = [];
                const promptForChatbot = `You are a knowledge graph analysis AI. Your task is to answer questions based *only* on the provided knowledge graph data. If the information is not present in the graph, state that you cannot answer the question based on the provided graph.

Knowledge Graph Data (JSON):
${graphJson}

User Question: ${userQuestion}`;

                chatHistoryForAI.push({ role: "user", parts: [{ text: promptForChatbot }] });
                const payload = {
                    contents: chatHistoryForAI
                };

                const apiKey = userApiKey;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Response for Chatbot:", result);

                let aiResponseText = "Could not get a response from the AI.";
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    aiResponseText = result.candidates[0].content.parts[0].text;
                }

                const aiMessageDiv = document.createElement('div');
                aiMessageDiv.classList.add('chat-message', 'ai');
                aiMessageDiv.textContent = aiResponseText;
                chatHistory.appendChild(aiMessageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;

            } catch (error) {
                console.error("Error communicating with chatbot AI:", error);
                const errorMessageDiv = document.createElement('div');
                errorMessageDiv.classList.add('chat-message', 'ai');
                errorMessageDiv.textContent = "Error: Failed to get a response from the AI. Please check your API key and network connection.";
                chatHistory.appendChild(errorMessageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;
            } finally {
                sendChatBtn.disabled = false;
                sendButtonText.style.display = 'inline';
                chatLoadingSpinner.classList.add('hidden');
            }
        });

        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !sendChatBtn.disabled) {
                event.preventDefault();
                sendChatBtn.click();
            }
        });

        // Node Info Pop-up functionality
        async function showNodeInfoPopup(nodeLabel, nodeX, nodeY) {
            nodeInfoPopup.classList.remove('hidden');
            popupNodeTitle.textContent = nodeLabel;
            popupNodeSummary.innerHTML = '<div class="popup-loading-spinner"></div>';

            const graphRect = graphContainer.getBoundingClientRect();
            const currentTransform = d3.zoomTransform(svg.node());

            const transformedX = graphRect.left + currentTransform.applyX(nodeX);
            const transformedY = graphRect.top + currentTransform.applyY(nodeY);

            // Set initial position before calculating offset
            nodeInfoPopup.style.left = `${transformedX}px`;
            nodeInfoPopup.style.top = `${transformedY}px`;
            nodeInfoPopup.style.display = 'flex'; // Temporarily show to get accurate dimensions

            const popupWidth = nodeInfoPopup.offsetWidth;
            const popupHeight = nodeInfoPopup.offsetHeight;

            let finalLeft = transformedX;
            let finalTop = transformedY;

            // Adjust if it goes off right edge
            if (finalLeft + popupWidth + 20 > window.innerWidth) { // 20px margin from edge
                finalLeft = window.innerWidth - popupWidth - 20;
            }
            // Adjust if it goes off bottom edge
            if (finalTop + popupHeight + 20 > window.innerHeight) { // 20px margin from edge
                finalTop = window.innerHeight - popupHeight - 20;
            }
            // Adjust if it goes off left edge
            if (finalLeft < 20) {
                finalLeft = 20;
            }
            // Adjust if it goes off top edge
            if (finalTop < 20) {
                finalTop = 20;
            }

            nodeInfoPopup.style.left = `${finalLeft}px`;
            nodeInfoPopup.style.top = `${finalTop}px`;
            nodeInfoPopup.style.display = 'flex'; // Final show

            try {
                const userApiKey = apiKeyInput.value.trim();
                if (!userApiKey) {
                    popupNodeSummary.textContent = "Please enter your Gemini API Key in the input modal to get node information.";
                    console.warn("API Key is missing for Node Summary request.");
                    return;
                }

                const graphJson = JSON.stringify({ nodes: currentGraphNodes, links: currentGraphLinks });

                let chatHistoryForAI = [];
                const promptForSummary = `You are a knowledge graph analysis AI. Provide a concise summary (2-3 sentences) about the concept "${nodeLabel}" based *only* on the provided knowledge graph data. If the information is not directly available or inferable from the graph, state that you cannot answer the question based on the provided graph.

Knowledge Graph Data (JSON):
${graphJson}

Concept to summarize: ${nodeLabel}`;

                chatHistoryForAI.push({ role: "user", parts: [{ text: promptForSummary }] });
                const payload = {
                    contents: chatHistoryForAI
                };

                const apiKey = userApiKey;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Response for Node Summary:", result);

                let summaryText = "The AI could not generate a summary for this node.";
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0 &&
                    result.candidates[0].content.parts[0].text) {
                    summaryText = result.candidates[0].content.parts[0].text;
                } else if (result.error) {
                    summaryText = `Error from AI: ${result.error.message || 'Unknown error'}`;
                    console.error("Gemini API Error for Node Summary:", result.error);
                } else {
                    summaryText = "The AI response was unexpected or empty. Could not generate summary.";
                    console.warn("Unexpected AI response structure for Node Summary:", result);
                }
                popupNodeSummary.textContent = summaryText;

            } catch (error) {
                console.error("Error fetching node summary:", error);
                popupNodeSummary.textContent = "Failed to load summary. Check API key or network connection.";
            }
        }

        closeNodeInfoPopupBtn.addEventListener('click', () => {
            nodeInfoPopup.style.display = 'none';
        });

        // This event listener will now correctly close the popover when clicking outside it
        // because the close button's z-index is higher and it correctly hides the popover.
        svg.on("click", () => {
            if (nodeInfoPopup.style.display !== 'none') {
                nodeInfoPopup.style.display = 'none';
            }
        });

        // Chatbot Draggability
        chatHeader.addEventListener('mousedown', (e) => {
            isDraggingChatbot = true;
            const rect = chatBotContainer.getBoundingClientRect();
            chatbotOffsetX = e.clientX - rect.left;
            chatbotOffsetY = e.clientY - rect.top;

            chatBotContainer.style.position = 'fixed';
            chatBotContainer.style.right = 'auto';
            chatBotContainer.style.bottom = 'auto';
            chatBotContainer.style.cursor = 'grabbing';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingChatbot) return;

            let newLeft = e.clientX - chatbotOffsetX;
            let newTop = e.clientY - chatbotOffsetY;

            const chatRect = chatBotContainer.getBoundingClientRect();
            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;
            if (newLeft + chatRect.width > window.innerWidth) newLeft = window.innerWidth - chatRect.width;
            if (newTop + chatRect.height > window.innerHeight) newTop = window.innerHeight - chatRect.height;

            chatBotContainer.style.left = `${newLeft}px`;
            chatBotContainer.style.top = `${newTop}px`;
        });

        document.addEventListener('mouseup', () => {
            isDraggingChatbot = false;
            chatBotContainer.style.cursor = 'grab';
        });

        // Initial setup on page load
        resizeGraph();
        // Show welcome portal first
        welcomePortal.classList.remove('hidden');
        openInputModalBtn.classList.add('hidden'); // Hide the main button until "Get Started" is clicked

        getStartedBtn.addEventListener('click', () => {
            welcomePortal.classList.add('hidden'); // Hide welcome portal
            openInputModalBtn.classList.remove('hidden'); // Show the main button
            handleOpenInputModal(); // Directly call the function to open the modal
        });

        // Manually trigger updateAuthUI to set up the input modal correctly without auth
        updateAuthUI(null);
    </script>
</body>
</html>