<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepGraph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Global Black & White Transparent Theme Styles */
        body {
            font-family: "Inter", sans-serif;
            background-color: #000000; /* Theme: background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* Full-screen Graph Container */
        #graphContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #000000; /* Full black for graph background */
            z-index: 1;
            overflow: hidden;
        }

        /* D3.js Graph Elements (Black & White Transparent Theme) */
        .link {
            stroke: rgba(255, 255, 255, 0.3); /* Slightly more visible white with transparency */
            stroke-opacity: 0.8; /* Increased opacity */
            stroke-width: 1.8px; /* Slightly thicker links */
            transition: stroke 0.2s ease-in-out;
        }
        .link:hover {
            stroke: rgba(255, 255, 255, 0.6);
        }

        .node circle {
            stroke: rgba(255, 255, 255, 0.5); /* More opaque white transparent stroke */
            stroke-width: 2.5px; /* Slightly thicker stroke */
            fill: rgba(255, 255, 255, 0.08); /* Slightly more visible transparent fill */
            cursor: pointer; /* Indicate clickable */
            transition: stroke 0.2s ease-in-out, fill 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .node circle:hover {
            stroke: rgba(255, 255, 255, 0.8); /* Even more opaque white on hover */
            fill: rgba(255, 255, 255, 0.15); /* More opaque white on hover */
            transform: scale(1.05); /* Slight scale effect on hover */
        }
        .node text {
            font-size: 0.95rem; /* Slightly smaller font for better fit */
            text-anchor: middle;
            fill: #e0e0e0; /* Slightly off-white for text */
            pointer-events: none;
            user-select: none;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5); /* Subtle text shadow for contrast */
        }
        .link-label {
            font-size: 0.8rem; /* Slightly smaller for labels */
            fill: #b0b0b0; /* Light gray for link labels */
            text-anchor: middle;
            user-select: none;
            font-weight: 500;
            transition: fill 0.2s ease-in-out;
        }
        .link-label:hover {
            fill: #ffffff; /* White on hover */
        }
        /* Arrowhead marker style */
        marker#arrow {
            fill: rgba(255, 255, 255, 0.3); /* Match link color with transparency */
            transition: fill 0.2s ease-in-out;
        }
        .link:hover marker#arrow { /* This won't work directly, marker fill needs to be controlled by CSS or re-rendered */
            fill: rgba(255, 255, 255, 0.6);
        }

        #graphPlaceholder {
            color: #d9d9da; /* Theme: default-800 */
            font-size: 1.8rem; /* Slightly larger */
            font-weight: 700; /* Bolder */
            letter-spacing: -0.02em;
        }

        /* Floating UI Card (Input Modal) */
        .floating-ui-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.65); /* Darker black transparent */
            backdrop-filter: blur(20px); /* Increased blur */
            border: 1px solid rgba(255, 255, 255, 0.15); /* Slightly more prominent border */
            border-radius: 25px; /* More rounded */
            padding: 40px;
            width: 90%;
            max-width: 750px; /* Slightly wider */
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6); /* Subtle shadow */
            transition: opacity 0.4s ease-out, transform 0.4s ease-out; /* Slower transition */
        }
        .floating-ui-card.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -40%); /* Slightly higher for hidden state */
        }

        /* Header Styling */
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .header h1 {
            font-size: 3.2rem; /* Larger title */
            font-weight: 900;
            color: #ffffff; /* Theme: foreground */
            letter-spacing: -0.04em; /* Tighter letter spacing */
            line-height: 1.1;
            margin-bottom: 12px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5); /* Stronger text shadow */
        }
        .header p {
            font-size: 1.15rem; /* Slightly larger paragraph */
            color: #c0c0c0; /* Lighter gray for readability */
            margin-top: 15px;
            max-width: 650px; /* Wider max width */
            margin-left: auto;
            margin-right: auto;
        }

        /* Textarea and Input Field Styles */
        textarea, input[type="text"], input[type="email"], input[type="password"] {
            min-height: 55px; /* Taller input fields */
            resize: vertical;
            border: 2px solid rgba(255, 255, 255, 0.2); /* More visible border */
            padding: 18px;
            border-radius: 12px; /* More rounded corners */
            font-size: 1.05rem; /* Slightly larger font */
            line-height: 1.6;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.5); /* Slightly darker background */
            width: 100%;
            box-sizing: border-box;
        }
        textarea {
            min-height: 220px; /* Taller textarea */
            background-color: rgba(255, 255, 255, 0.9); /* Very light, slightly transparent white */
            color: #1a1a1a; /* Darker text for contrast on light background */
        }
        textarea::placeholder, input::placeholder {
            color: rgba(255, 255, 255, 0.5); /* Placeholder color for dark inputs */
        }
        textarea:focus, input[type="text"]:focus, input[type="email"]:focus, input[type="password"]:focus {
            outline: none;
            border-color: #ffffff; /* Solid white border on focus */
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2); /* Subtle outer glow on focus */
        }
        textarea:focus {
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1); /* Darker shadow for light textarea */
        }
        label {
            color: #e0e0e0; /* Lighter label color */
        }

        .file-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 30px; /* More padding */
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px; /* More rounded */
            background-color: rgba(0, 0, 0, 0.4); /* Slightly darker background */
            cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.2s ease;
        }
        .file-upload-area:hover {
            background-color: rgba(0, 0, 0, 0.5);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px); /* Slight lift on hover */
        }
        .file-upload-area input[type="file"] {
            display: none;
        }
        .file-upload-area label {
            font-size: 1.1rem; /* Larger label */
            color: #ffffff;
            font-weight: 700;
            cursor: pointer;
        }
        .file-upload-area .file-icon {
            font-size: 3.5rem; /* Larger icon */
            color: #ffffff;
        }
        .file-upload-area #fileNameDisplay {
            color: #a0a0a0; /* Slightly darker gray for file name */
            font-size: 0.95rem;
        }

        .or-divider {
            display: flex;
            align-items: center;
            text-align: center;
            color: #a0a0a0; /* Darker gray for divider text */
            font-size: 1rem; /* Slightly larger */
            margin: 20px 0; /* More vertical space */
        }
        .or-divider::before,
        .or-divider::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15); /* More visible line */
        }
        .or-divider:not(:empty)::before {
            margin-right: 0.8em;
        }
        .or-divider:not(:empty)::after {
            margin-left: 0.8em;
        }

        /* Buttons */
        .main-button {
            background-image: linear-gradient(to right, #404041, #1e1e20); /* Slightly refined gradient */
            color: #ffffff;
            padding: 18px 40px; /* More padding */
            border-radius: 14px; /* More rounded */
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); /* Subtle shadow */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px; /* More space between text and icon */
            letter-spacing: 0.06em; /* Slightly more letter spacing */
            text-transform: uppercase;
            font-size: 1.15rem; /* Slightly larger font */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
        }
        .main-button.center-position {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .main-button.center-position:hover {
            background-image: linear-gradient(to right, #1e1e20, #0d0d0e);
            transform: translate(-50%, -50%) translateY(-5px); /* More pronounced lift */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6); /* Stronger shadow on hover */
        }
        .main-button.center-position:active {
            transform: translate(-50%, -50%) translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .main-button.top-left-position {
            position: fixed;
            top: 20px;
            left: 20px;
            transform: none;
            padding: 14px 28px; /* Slightly adjusted padding */
            font-size: 1.05rem; /* Slightly adjusted font size */
        }
        .main-button.top-left-position:hover {
            background-image: linear-gradient(to right, #1e1e20, #0d0d0e);
            transform: translateY(-3px); /* More pronounced lift */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
        }
        .main-button.top-left-position:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        .main-button:disabled {
            background-image: linear-gradient(to right, #505052, #303032); /* Darker disabled gradient */
            cursor: not-allowed;
            opacity: 0.6; /* Slightly less opaque */
            box-shadow: none;
        }
        .main-button.center-position:disabled {
            transform: translate(-50%, -50%);
        }
        .main-button.top-left-position:disabled {
            transform: none;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.4); /* Thicker and more transparent */
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 24px; /* Slightly smaller */
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Message Box */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1a1a1e; /* Darker background */
            padding: 40px; /* More padding */
            border-radius: 18px; /* More rounded */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); /* Stronger shadow */
            z-index: 1000;
            display: none;
            flex-direction: column;
            gap: 25px;
            align-items: center;
            text-align: center;
            max-width: 550px; /* Wider */
            width: 90%;
            border: 2px solid #3a3a3e; /* More prominent border */
        }
        .message-box p {
            font-size: 1.25rem; /* Larger font */
            color: #ffffff;
            line-height: 1.6;
        }
        .message-box button {
            background-image: linear-gradient(to right, #404041, #1e1e20);
            color: white;
            padding: 14px 35px; /* Larger padding */
            border-radius: 12px; /* More rounded */
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3); /* Subtle shadow */
            font-size: 1.05rem; /* Slightly larger */
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .message-box button:hover {
            background-image: linear-gradient(to right, #1e1e20, #0d0d0e);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        /* Progress Bar Overlay */
        #progressBarOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.95); /* Nearly opaque black */
            backdrop-filter: blur(10px); /* Stronger blur */
            z-index: 999;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 40px; /* More space */
            color: #ffffff;
            font-size: 1.8rem; /* Larger title text */
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        #progressBarContainer {
            width: 85%; /* Wider bar */
            max-width: 650px; /* Wider max width */
            background-color: rgba(255, 255, 255, 0.15); /* More visible background */
            border-radius: 15px; /* More rounded */
            height: 25px; /* Taller bar */
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.4); /* More prominent border */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); /* Inner shadow */
        }
        #progressBarFill {
            height: 100%;
            width: 0%;
            background-image: linear-gradient(to right, #ffffff, #e0e0e0); /* Brighter gradient */
            border-radius: 15px;
            transition: width 0.2s ease-out; /* Smoother transition */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3); /* Subtle glow on fill */
        }
        #progressText {
            margin-top: 15px;
            font-size: 1.25rem; /* Larger text */
            color: #d0d0d0; /* Lighter gray */
        }

        /* Chatbot Styles */
        #chatBotContainer {
            position: fixed;
            bottom: 25px; /* Slightly more off bottom */
            right: 25px; /* Slightly more off right */
            width: 380px; /* Slightly wider */
            height: 650px; /* Slightly taller */
            background-color: rgba(0, 0, 0, 0.8); /* Darker background */
            backdrop-filter: blur(12px); /* Increased blur */
            border: 1px solid rgba(255, 255, 255, 0.15); /* More prominent border */
            border-radius: 20px; /* More rounded */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); /* Stronger shadow */
            z-index: 20;
            display: none;
            flex-direction: column;
            overflow: hidden;
            cursor: grab;
        }
        #chatHeader {
            background-color: rgba(255, 255, 255, 0.15); /* More prominent header background */
            color: #ffffff;
            padding: 18px; /* More padding */
            font-weight: 700;
            font-size: 1.2rem; /* Larger font */
            border-bottom: 1px solid rgba(255, 255, 255, 0.25); /* More prominent border */
            text-align: center;
            cursor: grab;
        }
        #chatHistory {
            flex-grow: 1;
            padding: 20px; /* More padding */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px; /* More space between messages */
            scrollbar-width: thin;
            scrollbar-color: #a0a0a0 #0a0a0a; /* Lighter thumb, darker track */
        }
        #chatHistory::-webkit-scrollbar {
            width: 10px; /* Wider scrollbar */
        }
        #chatHistory::-webkit-scrollbar-track {
            background: #0a0a0a; /* Darker track */
            border-radius: 10px;
        }
        #chatHistory::-webkit-scrollbar-thumb {
            background-color: #a0a0a0; /* Lighter thumb */
            border-radius: 10px;
            border: 2px solid #0a0a0a; /* Darker border for thumb */
        }
        .chat-message {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 12px 18px; /* More padding */
            border-radius: 12px; /* More rounded */
            color: #e0e0e0; /* Lighter text */
            font-size: 0.95rem; /* Slightly larger font */
            line-height: 1.5;
            word-wrap: break-word;
        }
        .chat-message.user {
            align-self: flex-end;
            background-color: rgba(255, 255, 255, 0.2); /* More distinct user message */
            border-bottom-right-radius: 4px; /* Slightly larger corner adjustment */
        }
        .chat-message.ai {
            align-self: flex-start;
            background-color: rgba(255, 255, 255, 0.15); /* More distinct AI message */
            border-bottom-left-radius: 4px; /* Slightly larger corner adjustment */
        }
        #chatInputContainer {
            display: flex;
            padding: 18px; /* More padding */
            border-top: 1px solid rgba(255, 255, 255, 0.25); /* More prominent border */
            gap: 12px; /* More space */
        }
        #chatInput {
            flex-grow: 1;
            background-color: rgba(0, 0, 0, 0.6); /* Darker input background */
            border: 1px solid rgba(255, 255, 255, 0.35); /* More prominent border */
            border-radius: 10px; /* More rounded */
            padding: 12px 18px; /* More padding */
            color: #ffffff;
            font-size: 1rem; /* Slightly larger font */
        }
        #chatInput:focus {
            outline: none;
            border-color: #ffffff;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2); /* Subtle glow on focus */
        }
        #sendChatBtn {
            background-image: linear-gradient(to right, #404041, #1e1e20);
            color: white;
            padding: 12px 20px; /* More padding */
            border-radius: 10px; /* More rounded */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* Subtle shadow */
            font-size: 1rem; /* Slightly larger font */
            text-transform: none;
            letter-spacing: normal;
            position: static;
            transform: none;
        }
        #sendChatBtn:hover {
            background-image: linear-gradient(to right, #1e1e20, #0d0d0e);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        #sendChatBtn:disabled {
            background-image: linear-gradient(to right, #505052, #303032);
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        .chat-loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #ffffff;
            border-radius: 50%;
            width: 18px; /* Slightly larger */
            height: 18px;
            animation: spin 1s linear infinite;
        }

        /* Node Info Pop-up Styles */
        #nodeInfoPopup {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8); /* Darker background */
            backdrop-filter: blur(10px); /* Increased blur */
            border: 1px solid rgba(255, 255, 255, 0.2); /* More prominent border */
            border-radius: 18px; /* More rounded */
            padding: 25px; /* More padding */
            width: 320px; /* Slightly wider */
            max-height: 450px; /* Taller */
            overflow-y: auto;
            color: #ffffff;
            z-index: 50;
            display: none;
            flex-direction: column;
            gap: 12px; /* More space */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6); /* Stronger shadow */
            transform: translate(-50%, -50%);
            pointer-events: auto;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #nodeInfoPopup h3 {
            font-size: 1.5rem; /* Larger title */
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 8px;
            text-align: center;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        #nodeInfoPopup p {
            font-size: 0.95rem; /* Slightly larger text */
            line-height: 1.6;
            color: #d0d0d0; /* Lighter gray */
        }
        #nodeInfoPopup .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #ffffff;
            font-size: 1.8rem; /* Larger close button */
            cursor: pointer;
            padding: 8px; /* More padding */
            border-radius: 50%;
            transition: background-color 0.2s, transform 0.2s;
            z-index: 101 !important; /* Ensure this is on top */
        }
        #nodeInfoPopup .close-btn:hover {
            background-color: rgba(255, 255, 255, 0.15);
            transform: rotate(90deg); /* Rotate on hover */
        }
        #nodeInfoPopup .popup-loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 22px; /* Slightly larger */
            height: 22px;
            animation: spin 1s linear infinite;
            margin: 15px auto; /* More margin */
        }

        /* Welcome Portal Styles */
        #welcomePortal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.98); /* Nearly full black opaque background */
            z-index: 100; /* Above everything else initially */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            text-align: center;
            gap: 50px; /* More space */
            transition: opacity 0.6s ease-out; /* Slower transition */
        }
        #welcomePortal.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #welcomePortal h1 {
            font-size: 4.8rem; /* Even larger title */
            font-weight: 900;
            letter-spacing: -0.06em; /* Tighter letter spacing */
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.4); /* Stronger text shadow */
        }
        #welcomePortal p {
            font-size: 1.6rem; /* Larger paragraph */
            max-width: 900px; /* Wider max width */
            line-height: 1.7;
            color: #d8d8d8; /* Lighter gray for readability */
            padding: 0 20px; /* Padding for smaller screens */
        }
        #getStartedBtn {
            background-image: linear-gradient(to right, #404041, #1e1e20);
            color: white;
            padding: 22px 45px; /* Larger padding */
            border-radius: 18px; /* More rounded */
            font-weight: 800;
            font-size: 1.6rem; /* Larger font */
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5); /* Stronger shadow */
            text-transform: uppercase;
            letter-spacing: 0.1em; /* More letter spacing */
            border: 1px solid rgba(255, 255, 255, 0.15); /* Subtle border */
        }
        #getStartedBtn:hover {
            background-image: linear-gradient(to right, #1e1e20, #0d0d0e);
            transform: translateY(-5px); /* More pronounced lift */
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7); /* Even stronger shadow */
        }
        #getStartedBtn:active {
            transform: translateY(0);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .floating-ui-card {
                padding: 30px;
                gap: 20px;
                max-width: 95%;
            }
            .header h1 {
                font-size: 2.2rem;
            }
            .header p {
                font-size: 1rem;
            }
            textarea, input[type="text"] {
                min-height: 45px;
                padding: 15px;
                font-size: 0.95rem;
            }
            textarea {
                min-height: 180px;
            }
            .main-button {
                padding: 14px 30px;
                font-size: 1rem;
            }
            .file-upload-area {
                padding: 20px;
            }
            .file-upload-area .file-icon {
                font-size: 2.8rem;
            }
            #welcomePortal h1 {
                font-size: 3rem;
            }
            #welcomePortal p {
                font-size: 1.2rem;
            }
            #getStartedBtn {
                padding: 18px 35px;
                font-size: 1.2rem;
            }
            #chatBotContainer {
                width: 90vw;
                height: 70vh;
                bottom: 15px;
                right: 15px;
                left: 5vw; /* Center somewhat on smaller screens */
                top: auto;
            }
            #nodeInfoPopup {
                width: 90vw;
                max-height: 60vh;
                padding: 20px;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
            }
        }
    </style>
</head>
<body>
    <div id="welcomePortal">
        <h1>Welcome to DeepGraph</h1>
        <p>Transform complex research reports into interactive knowledge graphs and chat with AI to explore insights.</p>
        <button id="getStartedBtn">Get Started</button>
    </div>

    <div id="graphContainer">
        <svg id="knowledgeGraphSvg" class="w-full h-full absolute top-0 left-0"></svg>
        <div id="graphPlaceholder" class="absolute inset-0 flex items-center justify-center text-2xl font-semibold p-4">
            Your interactive knowledge graph will be visualized here.
        </div>
    </div>

    <button id="openInputModalBtn" class="main-button center-position hidden">
        <span id="openButtonText">Generate Knowledge Graph</span>
        <i class="fas fa-project-diagram"></i>
    </button>

    <div id="inputModal" class="floating-ui-card hidden">
        <div class="header">
            <h1 id="modalTitle">Generate Knowledge Graph</h1>
            <p id="modalSubtitle">Enter your report details below.</p>
        </div>

        <div id="reportInputSection">
            <div class="mb-4 mt-4">
                <label for="apiKeyInput" class="block text-gray-700 text-lg font-semibold mb-3">Gemini API Key:</label>
                <input type="text" id="apiKeyInput" class="w-full" placeholder="Enter your Gemini API Key here">
            </div>

            <div class="file-upload-area" id="fileUploadArea">
                <span class="file-icon"><i class="fas fa-file-pdf"></i></span>
                <label for="pdfUploadInput">Click to Upload PDF</label>
                <input type="file" id="pdfUploadInput" accept=".pdf">
                <span id="fileNameDisplay" class="text-gray-600 text-base font-medium">No file chosen</span>
                <div id="pdfLoadingSpinner" class="loading-spinner hidden"></div>
            </div>

            <div class="or-divider"><span>OR</span></div>

            <div>
                <label for="reportInput" class="block text-gray-700 text-lg font-semibold mb-3">Paste your research report here:</label>
                <textarea id="reportInput" class="w-full" placeholder="E.g., 'The study investigated the effects of climate change on polar bear populations. Rising temperatures lead to melting ice caps, reducing hunting grounds for seals, their primary food source. This results in decreased polar bear health and reproductive rates.'"></textarea>
            </div>

            <button id="submitInputBtn" class="main-button">
                <span id="submitButtonText">Generate Graph</span>
                <div id="submitLoadingSpinner" class="loading-spinner hidden"></div>
            </button>
        </div>
    </div>

    <div id="progressBarOverlay">
        <p>Generating Knowledge Graph...</p>
        <div id="progressBarContainer">
            <div id="progressBarFill"></div>
        </div>
        <span id="progressText">0%</span>
    </div>

    <div id="chatBotContainer">
        <div id="chatHeader">Chat with Graph AI <i class="fas fa-robot ml-2"></i></div>
        <div id="chatHistory">
            <div class="chat-message ai">Hello! Ask me anything about the knowledge graph.</div>
        </div>
        <div id="chatInputContainer">
            <input type="text" id="chatInput" placeholder="Ask about the graph...">
            <button id="sendChatBtn">
                <span id="sendButtonText">Send</span>
                <div id="chatLoadingSpinner" class="chat-loading-spinner hidden"></div>
            </button>
        </div>
    </div>

    <div id="nodeInfoPopup" class="hidden">
        <button class="close-btn" id="closeNodeInfoPopup"><i class="fas fa-times"></i></button>
        <h3 id="popupNodeTitle"></h3>
        <div id="popupNodeSummary">
            <div class="popup-loading-spinner"></div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageBoxText"></p>
        <button id="messageBoxOkBtn">OK</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // Set PDF.js worker source
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Global variables for Firebase (Canvas environment auth)
        let app;
        let auth;

        // Global variables to store the current graph data for chatbot
        let currentGraphNodes = [];
        let currentGraphLinks = [];

        // UI elements
        const welcomePortal = document.getElementById('welcomePortal');
        const getStartedBtn = document.getElementById('getStartedBtn');

        const openInputModalBtn = document.getElementById('openInputModalBtn');
        const inputModal = document.getElementById('inputModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalSubtitle = document.getElementById('modalSubtitle');

        const reportInputSection = document.getElementById('reportInputSection'); // Now always visible

        const reportInput = document.getElementById('reportInput');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const submitInputBtn = document.getElementById('submitInputBtn');
        const submitButtonText = document.getElementById('submitButtonText');
        const submitLoadingSpinner = document.getElementById('submitLoadingSpinner');
        const graphContainer = document.getElementById('graphContainer');
        const knowledgeGraphSvg = document.getElementById('knowledgeGraphSvg');
        const graphPlaceholder = document.getElementById('graphPlaceholder');
        const pdfUploadInput = document.getElementById('pdfUploadInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const pdfLoadingSpinner = document.getElementById('pdfLoadingSpinner');
        const fileUploadArea = document.getElementById('fileUploadArea');
        const progressBarOverlay = document.getElementById('progressBarOverlay');
        const progressBarFill = document.getElementById('progressBarFill');
        const progressText = document.getElementById('progressText');

        // Chatbot elements
        const chatBotContainer = document.getElementById('chatBotContainer');
        const chatHeader = document.getElementById('chatHeader');
        const chatHistory = document.getElementById('chatHistory');
        const chatInput = document.getElementById('chatInput');
        const sendChatBtn = document.getElementById('sendChatBtn');
        const sendButtonText = document.getElementById('sendButtonText');
        const chatLoadingSpinner = document.getElementById('chatLoadingSpinner');

        // Node Info Pop-up elements
        const nodeInfoPopup = document.getElementById('nodeInfoPopup');
        const closeNodeInfoPopupBtn = document.getElementById('closeNodeInfoPopup');
        const popupNodeTitle = document.getElementById('popupNodeTitle');
        const popupNodeSummary = document.getElementById('popupNodeSummary');

        let progressInterval;
        let isDraggingChatbot = false;
        let chatbotOffsetX, chatbotOffsetY;

        let width = window.innerWidth;
        let height = window.innerHeight;

        // --- Firebase Initialization (for Canvas environment) ---
        async function initializeFirebase() {
            try {
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing or empty.");
                    showMessageBox("Firebase configuration is missing. Please ensure the environment is set up correctly.");
                    return;
                }
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);

                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                console.log("Firebase initialized and authenticated for Canvas environment.");
            } catch (error) {
                console.error("Error initializing Firebase or authenticating:", error);
                showMessageBox("Failed to initialize Firebase or authenticate for Canvas. Please try again later.");
            }
        }
        initializeFirebase();

        function updateAuthUI(user) {
            // This function is simplified as auth is removed.
            // It now just ensures the report input section is visible.
            reportInputSection.classList.remove('hidden');
            modalTitle.textContent = "Generate Knowledge Graph";
            modalSubtitle.textContent = "Enter your report details below.";
        }

        // --- UI Event Listeners ---
        document.getElementById('messageBoxOkBtn').addEventListener('click', () => {
            document.getElementById('messageBox').style.display = 'none';
        });

        // Function to handle opening the input modal (simplified)
        async function handleOpenInputModal() {
            inputModal.classList.remove('hidden');
            updateAuthUI(null); // Call to ensure report input section is visible
        }

        // Open input/auth modal
        openInputModalBtn.addEventListener('click', handleOpenInputModal);

        // --- Existing App Logic ---
        const svg = d3.select("#knowledgeGraphSvg")
            .attr("viewBox", [0, 0, width, height]);

        svg.append("defs").append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("class", "arrowhead");

        const g = svg.append("g");

        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(200))
            .force("charge", d3.forceManyBody().strength(-500))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(30));

        let link, node, linkLabel;

        const zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
        svg.call(zoom);

        function resizeGraph() {
            width = window.innerWidth;
            height = window.innerHeight;
            svg.attr("viewBox", [0, 0, width, height]);
            simulation.force("center", d3.forceCenter(width / 2, height / 2));
            simulation.alpha(0.3).restart();
        }

        function renderGraph(nodes, links) {
            currentGraphNodes = nodes;
            currentGraphLinks = links;

            graphPlaceholder.classList.add('hidden');
            g.selectAll("*").remove();

            link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("class", "link")
                .attr("marker-end", "url(#arrow)");

            linkLabel = g.append("g")
                .attr("class", "link-labels")
                .selectAll("text")
                .data(links)
                .enter().append("text")
                .attr("class", "link-label")
                .text(d => d.type);

            node = g.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            node.append("circle")
                .attr("r", 18)
                .attr("fill", "rgba(255, 255, 255, 0.15)");

            node.append("text")
                .attr("dy", "0.35em")
                .attr("y", -25)
                .text(d => d.label);

            node.on("click", async (event, d) => {
                event.stopPropagation();
                await showNodeInfoPopup(d.label, d.x, d.y);
            });

            simulation
                .nodes(nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(links);

            simulation.alpha(1).restart();

            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                linkLabel
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2 - 10);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            }

            setMainButtonPosition('top-left');
            chatBotContainer.style.display = 'flex';
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function showMessageBox(message) {
            const messageBox = document.getElementById('messageBox');
            const messageBoxText = document.getElementById('messageBoxText');
            messageBoxText.textContent = message;
            messageBox.style.display = 'flex';
        }

        function setMainButtonPosition(position) {
            if (position === 'center') {
                openInputModalBtn.classList.remove('top-left-position');
                openInputModalBtn.classList.add('center-position');
            } else if (position === 'top-left') {
                openInputModalBtn.classList.remove('center-position');
                openInputModalBtn.classList.add('top-left-position');
            }
        }

        function setLoadingState(isLoading) {
            submitInputBtn.disabled = isLoading;
            if (isLoading) {
                submitButtonText.classList.add('hidden');
                submitLoadingSpinner.classList.remove('hidden');
            } else {
                submitButtonText.classList.remove('hidden');
                submitLoadingSpinner.classList.add('hidden');
            }
        }

        function setPdfLoadingState(isLoading) {
            pdfUploadInput.disabled = isLoading;
            fileUploadArea.style.cursor = isLoading ? 'not-allowed' : 'pointer';
            if (isLoading) {
                pdfLoadingSpinner.classList.remove('hidden');
                fileNameDisplay.textContent = 'Processing PDF...';
            } else {
                pdfLoadingSpinner.classList.add('hidden');
            }
        }

        function showProgressBar() {
            progressBarOverlay.style.display = 'flex';
            progressBarFill.style.width = '0%';
            progressText.textContent = '0%';
            let progress = 0;
            progressInterval = setInterval(() => {
                if (progress < 95) {
                    progress += Math.random() * 5;
                    if (progress > 95) progress = 95;
                    progressBarFill.style.width = `${progress}%`;
                    progressText.textContent = `${Math.floor(progress)}%`;
                }
            }, 200);
        }

        function hideProgressBar() {
            clearInterval(progressInterval);
            progressBarFill.style.width = '100%';
            progressText.textContent = '100%';
            setTimeout(() => {
                progressBarOverlay.style.display = 'none';
            }, 500);
        }

        pdfUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                fileNameDisplay.textContent = 'No file chosen';
                return;
            }

            if (file.type !== 'application/pdf') {
                showMessageBox("Please upload a valid PDF file.");
                fileNameDisplay.textContent = 'No file chosen';
                pdfUploadInput.value = '';
                return;
            }

            fileNameDisplay.textContent = file.name;
            setPdfLoadingState(true);
            reportInput.value = '';

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const pdfData = new Uint8Array(e.target.result);
                    const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                    const pdf = await loadingTask.promise;
                    let fullText = '';

                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + '\n';
                    }
                    reportInput.value = fullText.trim();
                    showMessageBox("PDF content loaded successfully into the text area. Click 'Generate Graph' to visualize.");
                } catch (error) {
                    console.error("Error processing PDF:", error);
                    showMessageBox("Failed to process PDF. It might be corrupted or in an unsupported format.");
                    reportInput.value = '';
                } finally {
                    setPdfLoadingState(false);
                }
            };
            reader.readAsArrayBuffer(file);
        });

        fileUploadArea.addEventListener('click', () => {
            if (!pdfUploadInput.disabled) {
                pdfUploadInput.click();
            }
        });

        submitInputBtn.addEventListener('click', async () => {
            const reportText = reportInput.value.trim();
            const userApiKey = apiKeyInput.value.trim();

            if (!userApiKey) {
                showMessageBox("Please enter your Gemini API Key.");
                return;
            }

            if (!reportText) {
                showMessageBox("Please enter a research report or upload a PDF to generate the knowledge graph.");
                return;
            }

            setLoadingState(true);
            inputModal.classList.add('hidden');
            showProgressBar();

            try {
                let chatHistory = [];
                const prompt = `Analyze the following research report and extract key concepts (nodes) and their relationships (links). Represent the output as a JSON object with two arrays: 'nodes' and 'links'.
Each node should have an 'id' (unique identifier, e.g., a simplified concept name) and a 'label' (the full concept name).
Each link should have a 'source' (id of the source node), a 'target' (id of the target node), and a 'type' (description of the relationship, e.g., 'explains', 'is_a', 'causes', 'has_property', 'impacts', 'leads_to', 'associated_with', 'part_of').
Ensure the relationships are meaningful and reflect the core ideas and connections within the text. Focus on scientific or technical concepts and their interdependencies.

Research Report:
${reportText}`;

                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "nodes": {
                                    "type": "ARRAY",
                                    "items": {
                                        "type": "OBJECT",
                                        "properties": {
                                            "id": { "type": "STRING" },
                                            "label": { "type": "STRING" }
                                        },
                                        "propertyOrdering": ["id", "label"]
                                    }
                                },
                                "links": {
                                    "type": "ARRAY",
                                    "items": {
                                        "type": "OBJECT",
                                        "properties": {
                                            "source": { "type": "STRING" },
                                            "target": { "type": "STRING" },
                                            "type": { "type": "STRING" }
                                        },
                                        "propertyOrdering": ["source", "target", "type"]
                                    }
                                }
                            },
                            "propertyOrdering": ["nodes", "links"]
                        }
                    }
                };

                const apiKey = userApiKey;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Response for Graph Generation:", result);

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;
                    const graphData = JSON.parse(jsonString);

                    if (graphData.nodes && graphData.links) {
                        renderGraph(graphData.nodes, graphData.links);
                    } else {
                        showMessageBox("The AI could not generate a valid knowledge graph from the provided text. This might happen with very short or unstructured text.");
                        graphPlaceholder.classList.remove('hidden');
                    }
                } else {
                    showMessageBox("Failed to get a response from the AI. Please check your API key or try again.");
                    graphPlaceholder.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Error generating knowledge graph:", error);
                showMessageBox("An error occurred while generating the knowledge graph. Please check your input and API key, then try again.");
                graphPlaceholder.classList.remove('hidden');
            } finally {
                setLoadingState(false);
                hideProgressBar();
            }
        });

        sendChatBtn.addEventListener('click', async () => {
            const userQuestion = chatInput.value.trim();
            if (!userQuestion) {
                showMessageBox("Please type a question for the chatbot.");
                return;
            }

            if (currentGraphNodes.length === 0) {
                showMessageBox("Please generate a knowledge graph first before asking questions.");
                chatInput.value = '';
                return;
            }

            const userMessageDiv = document.createElement('div');
            userMessageDiv.classList.add('chat-message', 'user');
            userMessageDiv.textContent = userQuestion;
            chatHistory.appendChild(userMessageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            chatInput.value = '';
            sendChatBtn.disabled = true;
            sendButtonText.classList.add('hidden');
            chatLoadingSpinner.classList.remove('hidden');

            try {
                const userApiKey = apiKeyInput.value.trim();
                if (!userApiKey) {
                    showMessageBox("Please enter your Gemini API Key in the input modal to use the chatbot.");
                    sendChatBtn.disabled = false;
                    sendButtonText.classList.remove('hidden');
                    chatLoadingSpinner.classList.add('hidden');
                    return;
                }

                const graphJson = JSON.stringify({ nodes: currentGraphNodes, links: currentGraphLinks });

                let chatHistoryForAI = [];
                const promptForChatbot = `You are a knowledge graph analysis AI. Your task is to answer questions based *only* on the provided knowledge graph data. If the information is not present in the graph, state that you cannot answer the question based on the provided graph.

Knowledge Graph Data (JSON):
${graphJson}

User Question: ${userQuestion}`;

                chatHistoryForAI.push({ role: "user", parts: [{ text: promptForChatbot }] });
                const payload = {
                    contents: chatHistoryForAI
                };

                const apiKey = userApiKey;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Response for Chatbot:", result);

                let aiResponseText = "Could not get a response from the AI.";
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    aiResponseText = result.candidates[0].content.parts[0].text;
                }

                const aiMessageDiv = document.createElement('div');
                aiMessageDiv.classList.add('chat-message', 'ai');
                aiMessageDiv.textContent = aiResponseText;
                chatHistory.appendChild(aiMessageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;

            } catch (error) {
                console.error("Error communicating with chatbot AI:", error);
                const errorMessageDiv = document.createElement('div');
                errorMessageDiv.classList.add('chat-message', 'ai');
                errorMessageDiv.textContent = "Error: Failed to get a response from the AI. Please check your API key and network connection.";
                chatHistory.appendChild(errorMessageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;
            } finally {
                sendChatBtn.disabled = false;
                sendButtonText.classList.remove('hidden');
                chatLoadingSpinner.classList.add('hidden');
            }
        });

        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !sendChatBtn.disabled) {
                event.preventDefault();
                sendChatBtn.click();
            }
        });

        // Node Info Pop-up functionality
        async function showNodeInfoPopup(nodeLabel, nodeX, nodeY) {
            nodeInfoPopup.classList.remove('hidden');
            popupNodeTitle.textContent = nodeLabel;
            popupNodeSummary.innerHTML = '<div class="popup-loading-spinner"></div>';

            const graphRect = graphContainer.getBoundingClientRect();
            const currentTransform = d3.zoomTransform(svg.node());

            const transformedX = graphRect.left + currentTransform.applyX(nodeX);
            const transformedY = graphRect.top + currentTransform.applyY(nodeY);

            // Set initial position before calculating offset
            nodeInfoPopup.style.left = `${transformedX}px`;
            nodeInfoPopup.style.top = `${transformedY}px`;
            nodeInfoPopup.style.display = 'flex'; // Temporarily show to get accurate dimensions

            const popupWidth = nodeInfoPopup.offsetWidth;
            const popupHeight = nodeInfoPopup.offsetHeight;

            let finalLeft = transformedX;
            let finalTop = transformedY;

            // Adjust if it goes off right edge
            if (finalLeft + popupWidth + 20 > window.innerWidth) { // 20px margin from edge
                finalLeft = window.innerWidth - popupWidth - 20;
            }
            // Adjust if it goes off bottom edge
            if (finalTop + popupHeight + 20 > window.innerHeight) { // 20px margin from edge
                finalTop = window.innerHeight - popupHeight - 20;
            }
            // Adjust if it goes off left edge
            if (finalLeft < 20) {
                finalLeft = 20;
            }
            // Adjust if it goes off top edge
            if (finalTop < 20) {
                finalTop = 20;
            }

            nodeInfoPopup.style.left = `${finalLeft}px`;
            nodeInfoPopup.style.top = `${finalTop}px`;
            nodeInfoPopup.style.display = 'flex'; // Final show

            try {
                const userApiKey = apiKeyInput.value.trim();
                if (!userApiKey) {
                    popupNodeSummary.textContent = "Please enter your Gemini API Key in the input modal to get node information.";
                    console.warn("API Key is missing for Node Summary request.");
                    return;
                }

                const graphJson = JSON.stringify({ nodes: currentGraphNodes, links: currentGraphLinks });

                let chatHistoryForAI = [];
                const promptForSummary = `You are a knowledge graph analysis AI. Provide a concise summary (2-3 sentences) about the concept "${nodeLabel}" based *only* on the provided knowledge graph data. If the information is not directly available or inferable from the graph, state that you cannot answer the question based on the provided graph.

Knowledge Graph Data (JSON):
${graphJson}

Concept to summarize: ${nodeLabel}`;

                chatHistoryForAI.push({ role: "user", parts: [{ text: promptForSummary }] });
                const payload = {
                    contents: chatHistoryForAI
                };

                const apiKey = userApiKey;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Response for Node Summary:", result);

                let summaryText = "The AI could not generate a summary for this node.";
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0 &&
                    result.candidates[0].content.parts[0].text) {
                    summaryText = result.candidates[0].content.parts[0].text;
                } else if (result.error) {
                    summaryText = `Error from AI: ${result.error.message || 'Unknown error'}`;
                    console.error("Gemini API Error for Node Summary:", result.error);
                } else {
                    summaryText = "The AI response was unexpected or empty. Could not generate summary.";
                    console.warn("Unexpected AI response structure for Node Summary:", result);
                }
                popupNodeSummary.textContent = summaryText;

            } catch (error) {
                console.error("Error fetching node summary:", error);
                popupNodeSummary.textContent = "Failed to load summary. Check API key or network connection.";
            }
        }

        closeNodeInfoPopupBtn.addEventListener('click', () => {
            nodeInfoPopup.style.display = 'none';
        });

        // This event listener will now correctly close the popover when clicking outside it
        // because the close button's z-index is higher and it correctly hides the popover.
        svg.on("click", () => {
            if (nodeInfoPopup.style.display !== 'none') {
                nodeInfoPopup.style.display = 'none';
            }
        });

        // Chatbot Draggability
        chatHeader.addEventListener('mousedown', (e) => {
            isDraggingChatbot = true;
            const rect = chatBotContainer.getBoundingClientRect();
            chatbotOffsetX = e.clientX - rect.left;
            chatbotOffsetY = e.clientY - rect.top;

            chatBotContainer.style.position = 'fixed';
            chatBotContainer.style.right = 'auto';
            chatBotContainer.style.bottom = 'auto';
            chatBotContainer.style.cursor = 'grabbing';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingChatbot) return;

            let newLeft = e.clientX - chatbotOffsetX;
            let newTop = e.clientY - chatbotOffsetY;

            const chatRect = chatBotContainer.getBoundingClientRect();
            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;
            if (newLeft + chatRect.width > window.innerWidth) newLeft = window.innerWidth - chatRect.width;
            if (newTop + chatRect.height > window.innerHeight) newTop = window.innerHeight - chatRect.height;

            chatBotContainer.style.left = `${newLeft}px`;
            chatBotContainer.style.top = `${newTop}px`;
        });

        document.addEventListener('mouseup', () => {
            isDraggingChatbot = false;
            chatBotContainer.style.cursor = 'grab';
        });

        // Initial setup on page load
        resizeGraph();
        // Show welcome portal first
        welcomePortal.classList.remove('hidden');
        openInputModalBtn.classList.add('hidden'); // Hide the main button until "Get Started" is clicked

        getStartedBtn.addEventListener('click', () => {
            welcomePortal.classList.add('hidden'); // Hide welcome portal
            openInputModalBtn.classList.remove('hidden'); // Show the main button
            handleOpenInputModal(); // Directly call the function to open the modal
        });

        // Manually trigger updateAuthUI to set up the input modal correctly without auth
        updateAuthUI(null);
    </script>
</body>
</html>